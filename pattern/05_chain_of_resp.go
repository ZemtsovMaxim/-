package pattern

/*
	Реализовать паттерн «цепочка вызовов».
	Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern

	Цепочка обязанностей — это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков.
	Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.
	Как и многие другие поведенческие паттерны, Цепочка обязанностей базируется на том, чтобы превратить отдельные поведения в объекты.
	В нашем случае каждая проверка переедет в отдельный класс с единственным методом выполнения.
	Данные запроса, над которым происходит проверка, будут передаваться в метод как аргументы.

	+
	Уменьшает зависимость между клиентом и обработчиками.
 	Реализует принцип единственной обязанности.
 	Реализует принцип открытости/закрытости.

	-
 	Запрос может остаться никем не обработанным.
*/

import "fmt"

// Handler определяет общий интерфейс для всех обработчиков
type Handler interface {
	HandleRequest(request int)
	SetNext(handler Handler)
}

// ConcreteHandler реализует интерфейс Handler и обрабатывает запрос, если он может его обработать
type ConcreteHandler struct {
	next Handler
}

func (c *ConcreteHandler) SetNext(handler Handler) {
	c.next = handler
}

// HandleRequest обрабатывает запрос, если может, или передает его следующему обработчику
func (c *ConcreteHandler) HandleRequest(request int) {
	fmt.Println("ConcreteHandler: обработка запроса")
	if c.next != nil {
		c.next.HandleRequest(request)
	}
}

// Пример использования

func ExampleUsage() {
	// Создаем объекты обработчиков
	handler1 := &ConcreteHandler{}
	handler2 := &ConcreteHandler{}
	handler3 := &ConcreteHandler{}

	// Устанавливаем следующий обработчик для каждого обработчика
	handler1.SetNext(handler2)
	handler2.SetNext(handler3)

	// Передаем запрос через цепочку обработчиков
	handler1.HandleRequest(1)
}
